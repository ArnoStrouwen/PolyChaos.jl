<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · PolyChaos.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/myfont.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="PolyChaos.jl logo"/></a><h1>PolyChaos.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Overview</a></li><li><a class="toctext" href="../type_hierarchy/">Type Hierarchy</a></li><li><span class="toctext">Usage</span><ul><li><a class="toctext" href="../numerical_integration/">Numerical Integration</a></li><li><a class="toctext" href="../quadrature_rules/">Quadrature Rules</a></li><li><a class="toctext" href="../orthogonal_polynomials_canonical/">Univariate Monic Orthogonal Polynomials</a></li><li><a class="toctext" href="../multiple_discretization/">Multiple Discretization</a></li><li><a class="toctext" href="../scalar_products/">Computation of Scalar Products</a></li><li><span class="toctext">Polynomial Chaos</span><ul><li><a class="toctext" href="../pce_tutorial/">Basic Usage</a></li><li><a class="toctext" href="../chi_squared_k1/">Chi Squared, One DOF</a></li><li><a class="toctext" href="../chi_squared_k_greater1/">Chi Squared, Several DOFs</a></li><li><a class="toctext" href="../random_ode/">Random ODE</a></li></ul></li></ul></li><li><a class="toctext" href="../math/">Mathematical Background</a></li><li class="current"><a class="toctext" href>Functions</a><ul class="internal"><li><a class="toctext" href="#Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials-1">Recurrence Coefficients for Monic Orthogonal Polynomials</a></li><li><a class="toctext" href="#Show-Orthogonal-Polynomials-1">Show Orthogonal Polynomials</a></li><li><a class="toctext" href="#Evaluate-Orthogonal-Polynomials-1">Evaluate Orthogonal Polynomials</a></li><li><a class="toctext" href="#Scalar-Products-1">Scalar Products</a></li><li><a class="toctext" href="#Quadrature-Rules-1">Quadrature Rules</a></li><li><a class="toctext" href="#Polynomial-Chaos-1">Polynomial Chaos</a></li><li><a class="toctext" href="#Auxiliary-Functions-1">Auxiliary Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Functions</a></li></ul><a class="edit-page" href="https://github.com/timueh/PolyChaos.jl/blob/master/docs/src/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The core interface of (so we hope) all essential functions are <em>not</em> dependent on specialized types such as <code>OrthoPoly</code>/<code>OrthoPolyQ</code>. Having said that, for exactly those essential functions there exist overloaded functions that accept specialized types such as <code>OrthoPoly</code>/<code>OrthoPolyQ</code> as arguments.</p><p>Too abstract? For example, the function <code>evaluate()</code> that evaluates a polynomial of degree <code>n</code> at points <code>x</code> has the core interface</p><pre><code class="language-none">    evaluate(n::Int64,x::Array{Float64},a::Vector{Float64},b::Vector{Float64})</code></pre><p>where <code>a</code> and <code>b</code> are the vectors of recurrence coefficients. For simplicity, there also exists the interface</p><pre><code class="language-none">    evaluate(n::Int64,x::Vector{Float64},op::OrthoPoly)</code></pre><p>which is defined as</p><pre><code class="language-none">    evaluate(n::Int64,x::Vector{Float64},op::OrthoPoly) = evaluate(n,x,op.α,op.β)</code></pre><p>So fret not upon the encounter of multiply-dispatched versions of the same thing. It&#39;s there to simplify your life (so we hope).</p><p>The idea of this approach is to make it simpler for others to copy and paste code snippets and use them in their own work.</p></div></div><p>List of all functions in <code>PolyChaos</code>.</p><ul><li><a href="#LinearAlgebra.issymmetric"><code>LinearAlgebra.issymmetric</code></a></li><li><a href="#PolyChaos.calculateAffinePCE"><code>PolyChaos.calculateAffinePCE</code></a></li><li><a href="#PolyChaos.clenshaw_curtis"><code>PolyChaos.clenshaw_curtis</code></a></li><li><a href="#PolyChaos.coeffs"><code>PolyChaos.coeffs</code></a></li><li><a href="#PolyChaos.computeSP"><code>PolyChaos.computeSP</code></a></li><li><a href="#PolyChaos.computeSP2"><code>PolyChaos.computeSP2</code></a></li><li><a href="#PolyChaos.convert2affinePCE"><code>PolyChaos.convert2affinePCE</code></a></li><li><a href="#PolyChaos.evaluate"><code>PolyChaos.evaluate</code></a></li><li><a href="#PolyChaos.evaluatePCE"><code>PolyChaos.evaluatePCE</code></a></li><li><a href="#PolyChaos.fejer"><code>PolyChaos.fejer</code></a></li><li><a href="#PolyChaos.fejer2"><code>PolyChaos.fejer2</code></a></li><li><a href="#PolyChaos.gauss"><code>PolyChaos.gauss</code></a></li><li><a href="#PolyChaos.integrate"><code>PolyChaos.integrate</code></a></li><li><a href="#PolyChaos.lanczos"><code>PolyChaos.lanczos</code></a></li><li><a href="#PolyChaos.lobatto"><code>PolyChaos.lobatto</code></a></li><li><a href="#PolyChaos.mcdiscretization"><code>PolyChaos.mcdiscretization</code></a></li><li><a href="#PolyChaos.nw"><code>PolyChaos.nw</code></a></li><li><a href="#PolyChaos.quadgp"><code>PolyChaos.quadgp</code></a></li><li><a href="#PolyChaos.r_scale-Tuple{Float64,Array{Float64,1},Array{Float64,1}}"><code>PolyChaos.r_scale</code></a></li><li><a href="#PolyChaos.radau"><code>PolyChaos.radau</code></a></li><li><a href="#PolyChaos.rec2coeff"><code>PolyChaos.rec2coeff</code></a></li><li><a href="#PolyChaos.rm_compute-Tuple{Function,Float64,Float64}"><code>PolyChaos.rm_compute</code></a></li><li><a href="#PolyChaos.rm_hermite-Tuple{Int64,Float64}"><code>PolyChaos.rm_hermite</code></a></li><li><a href="#PolyChaos.rm_hermite_prob-Tuple{Int64}"><code>PolyChaos.rm_hermite_prob</code></a></li><li><a href="#PolyChaos.rm_jacobi-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_jacobi</code></a></li><li><a href="#PolyChaos.rm_jacobi01-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_jacobi01</code></a></li><li><a href="#PolyChaos.rm_laguerre-Tuple{Int64,Float64}"><code>PolyChaos.rm_laguerre</code></a></li><li><a href="#PolyChaos.rm_legendre-Tuple{Int64}"><code>PolyChaos.rm_legendre</code></a></li><li><a href="#PolyChaos.rm_legendre01-Tuple{Int64}"><code>PolyChaos.rm_legendre01</code></a></li><li><a href="#PolyChaos.rm_logistic-Tuple{Int64}"><code>PolyChaos.rm_logistic</code></a></li><li><a href="#PolyChaos.rm_meixner_pollaczek-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_meixner_pollaczek</code></a></li><li><a href="#PolyChaos.sampleMeasure"><code>PolyChaos.sampleMeasure</code></a></li><li><a href="#PolyChaos.samplePCE"><code>PolyChaos.samplePCE</code></a></li><li><a href="#PolyChaos.showpoly"><code>PolyChaos.showpoly</code></a></li><li><a href="#PolyChaos.stieltjes"><code>PolyChaos.stieltjes</code></a></li><li><a href="#Statistics.mean"><code>Statistics.mean</code></a></li><li><a href="#Statistics.std"><code>Statistics.std</code></a></li><li><a href="#Statistics.var"><code>Statistics.var</code></a></li></ul><h2><a class="nav-anchor" id="Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials-1" href="#Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials-1">Recurrence Coefficients for Monic Orthogonal Polynomials</a></h2><p>The functions below provide analytic expressions for the recurrence coefficients of common orthogonal polynomials. All of these provide <em>monic orthogonal polynomials</em> relative to the weights.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The number <code>N</code> of recurrence coefficients has to be positive for all functions below.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.r_scale-Tuple{Float64,Array{Float64,1},Array{Float64,1}}" href="#PolyChaos.r_scale-Tuple{Float64,Array{Float64,1},Array{Float64,1}}"><code>PolyChaos.r_scale</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">r_scale(c::Float64,β::Vector{Float64},α::Vector{Float64})</code></pre><p>Given the recursion coefficients <code>(α,β)</code> for a system of orthogonal polynomials that are orthogonal with respect to some positive weight <span>$m(t)$</span>, this function returns the recursion coefficients <code>(α_,β_)</code> for the scaled measure <span>$c m(t)$</span> for some positive <span>$c$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L16-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_compute-Tuple{Function,Float64,Float64}" href="#PolyChaos.rm_compute-Tuple{Function,Float64,Float64}"><code>PolyChaos.rm_compute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_compute(weight::Function,lb::Float64,ub::Float64,Npoly::Int64=4,Nquad::Int64=10;quadrature::Function=clenshaw_curtis)</code></pre><p>Given a positive <code>weight</code> function with domain <code>(lb,ub)</code>, i.e. a function <span>$w: [lb, ub ] \rightarrow \mathbb{R}_{\geq 0}$</span>, this function creates <code>Npoly</code> recursion coefficients <code>(α,β)</code>.</p><p>The keyword <code>quadrature</code> specifies what quadrature rule is being used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L26-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_logistic-Tuple{Int64}" href="#PolyChaos.rm_logistic-Tuple{Int64}"><code>PolyChaos.rm_logistic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_logistic(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic polynomials that are orthogonal on <span>$(-\infty,\infty)$</span> relative to <span>$w(t) = \frac{\mathrm{e}^{-t}}{(1 - \mathrm{e}^{-t})^2}$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L74-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_hermite-Tuple{Int64,Float64}" href="#PolyChaos.rm_hermite-Tuple{Int64,Float64}"><code>PolyChaos.rm_hermite</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_hermite(N::Int,mu::Float64)
rm_hermite(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic generalized Hermite polynomials that are orthogonal on <span>$(-\infty,\infty)$</span> relative to <span>$w(t) = |t|^{2 \mu} \mathrm{e}^{-t^2}$</span></p><p>The call <code>rm_hermite(N)</code> is the same as <code>rm_hermite(N,0)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L85-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_hermite_prob-Tuple{Int64}" href="#PolyChaos.rm_hermite_prob-Tuple{Int64}"><code>PolyChaos.rm_hermite_prob</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_hermite_prob(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic probabilists&#39; Hermite polynomials that are orthogonal on <span>$(-\infty,\infty)$</span> relative to <span>$w(t) = \mathrm{e}^{-0.5t^2}$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L102-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_laguerre-Tuple{Int64,Float64}" href="#PolyChaos.rm_laguerre-Tuple{Int64,Float64}"><code>PolyChaos.rm_laguerre</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_laguerre(N::Int,a::Float64)
rm_laguerre(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic generalized Laguerre polynomials that are orthogonal on <span>$(0,\infty)$</span> relative to <span>$w(t) = t^a \mathrm{e}^{-t}$</span>.</p><p>The call <code>rm_laguerre(N)</code> is the same as <code>rm_laguerre(N,0)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L114-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_legendre-Tuple{Int64}" href="#PolyChaos.rm_legendre-Tuple{Int64}"><code>PolyChaos.rm_legendre</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_legendre(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Legendre polynomials that are orthogonal on <span>$(-1,1)$</span> relative to <span>$w(t) = 1$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L180-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_legendre01-Tuple{Int64}" href="#PolyChaos.rm_legendre01-Tuple{Int64}"><code>PolyChaos.rm_legendre01</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_legendre01(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Legendre polynomials that are orthogonal on <span>$(0,1)$</span> relative to <span>$w(t) = 1$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L188-L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_jacobi-Tuple{Int64,Float64,Float64}" href="#PolyChaos.rm_jacobi-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_jacobi</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_jacobi(N::Int,a::Float64,b::Float64)
rm_jacobi(N::Int,a::Float64)
rm_jacobi(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Jacobi polynomials that are orthogonal on <span>$(-1,1)$</span> relative to <span>$w(t) = (1-t)^a (1+t)^b$</span>.</p><p>The call <code>rm_jacobi(N,a)</code> is the same as <code>rm_jacobi(N,a,a)</code> and <code>rm_jacobi(N)</code> the same as <code>rm_jacobi(N,0,0)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L133-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_jacobi01-Tuple{Int64,Float64,Float64}" href="#PolyChaos.rm_jacobi01-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_jacobi01</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_jacobi01(N::Int,a::Float64,b::Float64)
rm_jacobi01(N::Int,a::Float64)
rm_jacobi01(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Jacobi polynomials that are orthogonal on <span>$(0,1)$</span> relative to <span>$w(t) = (1-t)^a t^b$</span>.</p><p>The call <code>rm_jacobi01(N,a)</code> is the same as <code>rm_jacobi01(N,a,a)</code> and <code>rm_jacobi01(N)</code> the same as <code>rm_jacobi01(N,0,0)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L160-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rm_meixner_pollaczek-Tuple{Int64,Float64,Float64}" href="#PolyChaos.rm_meixner_pollaczek-Tuple{Int64,Float64,Float64}"><code>PolyChaos.rm_meixner_pollaczek</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rm_meixner_pollaczek(N::Int,lambda::Float64,phi::Float64)
rm_meixner_pollaczek(N::Int,lambda::Float64)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic  Meixner-Pollaczek polynomials with parameters λ and ϕ. These are orthogonal on  <span>$[-\infty,\infty]$</span> relative to the weight function <span>$w(t)=(2 \pi)^{-1} \exp{(2 \phi-\pi)t} |\Gamma(\lambda+ i t)|^2$</span>.</p><p>The call <code>rm_meixner_pollaczek(n,lambda)</code> is the same as <code>rm_meixner_pollaczek(n,lambda,pi/2)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/recurrence_coefficients_monic.jl#L252-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.stieltjes" href="#PolyChaos.stieltjes"><code>PolyChaos.stieltjes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stieltjes(N::Int64,nodes_::Vector{Float64},weights_::Vector{Float64};removezeroweights::Bool=true)</code></pre><p>Stieltjes procedure–-Given the nodes and weights the function generates the first<code>N</code> recurrence coefficients of the corresponding discrete orthogonal polynomials.</p><p>Set the Boolean <code>removezeroweights</code> to <code>true</code> if zero weights should be removed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/stieltjes.jl#L12-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.lanczos" href="#PolyChaos.lanczos"><code>PolyChaos.lanczos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lanczos(N::Int64,nodes::Vector{Float64},weights::Vector{Float64};removezeroweights::Bool=true)</code></pre><p>Lanczos procedure–-given the nodes and weights the function generates the first <code>N</code> recurrence coefficients of the corresponding discrete orthogonal polynomials.</p><p>Set the Boolean <code>removezeroweights</code> to <code>true</code> if zero weights should be removed.</p><p>The script is adapted from the routine RKPW in W.B. Gragg and W.J. Harrod, <em>The numerically stable reconstruction of Jacobi matrices from spectral data</em>, Numer. Math. 44 (1984), 317-335.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/stieltjes.jl#L50-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.mcdiscretization" href="#PolyChaos.mcdiscretization"><code>PolyChaos.mcdiscretization</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mcdiscretization(N::Int64,quads::Vector{},discretemeasure::Matrix{Float64}=zeros(0,2);discretization::Function=stieltjes,Nmax::Integer=300,ε::Float64=1e-8,gaussquad::Bool=false)</code></pre><p>This routine returns <span>$N$</span> recurrence coefficients of the polynomials that are orthogonal relative to a weight function <span>$w$</span> that is decomposed as a sum of <span>$m$</span> weights <span>$w_i$</span> with domains <span>$[a_i,b_i]$</span> for <span>$i=1,\dots,m$</span>,</p><div>\[w(t) = \sum_{i}^{m} w_i(t) \quad \text{with } \operatorname{dom}(w_i) = [a_i, b_i].\]</div><p>For each weight <span>$w_i$</span> and its domain <span>$[a_i, b_i]$</span> the function <code>mcdiscretization()</code> expects a quadrature rule of the form     nodes::Vector{Float64}, weights::Vector{Float64} = my<em>quad</em>i(N::Int64) all of which are stacked in the parameter <code>quad</code>     quad = [ my<em>quad</em>1, ..., my<em>quad</em>m ] If the weight function has a discrete part (specified by <code>discretemeasure</code>) it is added on to the discretized continuous weight function.</p><p>The function <code>mcdiscretization()</code> performs a sequence of discretizations of the given weight <span>$w(t)$</span>, each discretization being followed by an application of the Stieltjes or Lanczos procedure (keyword <code>discretization in [stieltjes, lanczos]</code>) to produce approximations to the desired recurrence coefficients. The function applies to each subinterval <span>$i$</span> an <code>N</code>-point quadrature rule (the <span>$i$</span>th entry of <code>quad</code>) to discretize the weight function <span>$w_i$</span> on that subinterval. If the procedure converges to within a prescribed accuracy <code>ε</code> before <code>N</code> reaches its maximum allowed value <code>Nmax</code>. If the function does not converge, the function prompts an error message.</p><p>The keyword <code>gaussquad</code> should be set to <code>true</code> if Gauss quadrature rules are available <em>for all</em> <span>$m$</span> weights <span>$w_i(t)$</span> with <span>$i = 1, \dots, m$</span>.</p><p>For further information, please see W. Gautschi &quot;Orthogonal Polynomials: Approximation and Computation&quot;, Section 2.2.4.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/stieltjes.jl#L116-L148">source</a></section><h2><a class="nav-anchor" id="Show-Orthogonal-Polynomials-1" href="#Show-Orthogonal-Polynomials-1">Show Orthogonal Polynomials</a></h2><p>To get a human-readable output of the orthognoal polynomials there is the function <code>showpoly()</code></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.showpoly" href="#PolyChaos.showpoly"><code>PolyChaos.showpoly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">showpoly(coeffs::Vector{Float64};sym::String,digits::Integer)
showpoly(coeffs::Vector{Vector{Float64}};sym::String,digits::Integer)</code></pre><p>Show the monic polynomial with coefficients <code>coeffs</code> in a human readable way. They keyword <code>sym</code> sets the name of the variable, and <code>digits</code> controls the number of shown digits.</p><pre><code class="language-">julia&gt; showpoly([1.2, 2.3, 3.4456])
x^3 + 3.45x^2 + 2.3x + 1.2
julia&gt; showpoly([1.2, 2.3, 3.4456], sym=&quot;t&quot;, digits=2)
t^3 + 3.45t^2 + 2.3t + 1.2</code></pre><p>Tailored to types from <code>PolyChaos.jl</code></p><pre><code class="language-none">showpoly(d::Integer,α::Vector{Float64},β::Vector{Float64};upto::Bool,sym::String,digits::Integer)
showpoly(d::Integer,op::OrthoPoly;upto::Bool=true,sym::String,digits::Integer)
showpoly(d::Integer,opq::OrthoPolyQ;upto::Bool=true,sym::String,digits::Integer)</code></pre><p>Show the monic orthogonal polynomials with recurrence coefficients <code>(α,β)</code> up to degree <code>d</code>. Setting the keyword <code>upto</code> to false prints the monic polynomial of degree equal to <code>d</code>.</p><pre><code class="language-">julia&gt; op = OrthoPoly(&quot;gaussian&quot;,5);
julia&gt; showpoly(3,op)
1
x
x^2 - 1.0
x^3 - 3.0x

julia&gt; showpoly(3,op; upto=false)
x^3 - 3.0x

julia&gt; showpoly(3,op; sym=&quot;t&quot;)
1
t
t^2 - 1.0
t^3 - 3.0t</code></pre><p>The following function calls show all orthogonal polynomials given <code>(α,β)</code>.</p><pre><code class="language-none">showpoly(α::Vector{Float64},β::Vector{Float64};sym::String,digits::Integer)
showpoly(op::Union{OrthoPoly,OrthoPolyQ};sym::String,digits::Integer)</code></pre><pre><code class="language-">julia&gt; showpoly(op; sym=&quot;y&quot;)
1
y
y^2 - 1.0
y^3 - 3.0y
y^4 - 6.0y^2 + 3.0
y^5 - 10.0y^3 + 15.0y
y^6 - 15.0y^4 + 45.0y^2 - 15.0</code></pre><p><a href="https://discourse.julialang.org/t/how-to-define-verbose-output-for-a-polynomial/21317/5">Thanks @pfitzseb for providing this functionality.</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/show.jl#L145-L204">source</a></section><p>This function makes excessive use of</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.rec2coeff" href="#PolyChaos.rec2coeff"><code>PolyChaos.rec2coeff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rec2coeff(deg::Int,a::Vector{Float64},b::Vector{Float64})
rec2coeff(a,b) = rec2coeff(length(a),a,b)</code></pre><p>Get the coefficients of the orthogonal polynomial of degree up to <code>deg</code> specified by its recurrence coefficients <code>(a,b)</code>. The function returns the values <span>$c_i^{(k)}$</span> from</p><div>\[p_k (t) = t^d + \sum_{i=0}^{k-1} c_i t^i,\]</div><p>where <span>$k$</span> runs from <code>1</code> to <code>deg</code>.</p><p>The call <code>rec2coeff(a,b)</code> outputs all possible recurrence coefficients given <code>(a,b)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/show.jl#L111-L124">source</a></section><h2><a class="nav-anchor" id="Evaluate-Orthogonal-Polynomials-1" href="#Evaluate-Orthogonal-Polynomials-1">Evaluate Orthogonal Polynomials</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.evaluate" href="#PolyChaos.evaluate"><code>PolyChaos.evaluate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">evaluate(n::Int64,x::Array{Float64},a::Vector{Float64},b::Vector{Float64})
evaluate(n::Int64,x::Float64,a::Vector{Float64},b::Vector{Float64})
evaluate(n::Int64,x::Vector{Float64},op::OrthoPoly)
evaluate(n::Int64,x::Float64,op::OrthoPoly)
evaluate(n::Int64,x::Vector{Float64},opq::OrthoPolyQ) = evaluate(n,x,opq.op)
evaluate(n::Int64,x::Float64,opq::OrthoPolyQ) = evaluate(n,[x],opq.op)</code></pre><p>Evaluate the <code>n</code>-th univariate basis polynomial at point(s) <code>x</code> The function is multiply dispatched to facilitate its use with the composite type <code>OrthoPoly</code></p><p>If several basis polynomials (stored in <code>ns</code>) are to be evaluated at points <code>x</code>, then call</p><pre><code class="language-none">evaluate(ns::Vector{Int64},x::Vector{Float64},op::OrthoPoly) = evaluate(ns,x,op.α,op.β)
evaluate(ns::Vector{Int64},x::Float64,op::OrthoPoly) = evaluate(ns,[x],op)
evaluate(ns::Vector{Int64},x::Vector{Float64},opq::OrthoPolyQ) = evaluate(ns,x,opq.op)
evaluate(ns::Vector{Int64},x::Float64,opq::OrthoPolyQ) = evaluate(ns,[x],opq.op)</code></pre><p>If <em>all</em> basis polynomials are to be evaluated at points <code>x</code>, then call</p><pre><code class="language-none">evaluate(x::Vector{Float64},op::OrthoPoly) = evaluate(collect(0:op.deg),x,op)
evaluate(x::Float64,op::OrthoPoly) = evaluate([x],op)
evaluate(x::Vector{Float64},opq::OrthoPolyQ) = evaluate(x,opq.op)
evaluate(x::Float64,opq::OrthoPolyQ) = evaluate([x],opq)</code></pre><p>which returns an Array of dimensions <code>(length(x),op.deg+1)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ul><li><code>n</code> is the degree of the univariate basis polynomial</li><li><code>length(x) = N</code>, where <code>N</code> is the number of points</li><li><code>(a,b)</code> are the recursion coefficients</li></ul></div></div><p><strong>Multivariate</strong></p><pre><code class="language-none">evaluate(n::Vector{Int64},x::Matrix{Float64},a::Vector{Vector{Float64}},b::Vector{Vector{Float64}})
evaluate(n::Vector{Int64},x::Vector{Float64},a::Vector{Vector{Float64}},b::Vector{Vector{Float64}})
evaluate(n::Vector{Int64},x::Matrix{Float64},op::MultiOrthoPoly)
evaluate(n::Vector{Int64},x::Vector{Float64},op::MultiOrthoPoly)</code></pre><p>Evaluate the n-th p-variate basis polynomial at point(s) x The function is multiply dispatched to facilitate its use with the composite type <code>MultiOrthoPoly</code></p><p>If several basis polynomials are to be evaluated at points <code>x</code>, then call</p><pre><code class="language-none">evaluate(ind::Matrix{Int64},x::Matrix{Float64},a::Vector{Vector{Float64}},b::Vector{Vector{Float64}})
evaluate(ind::Matrix{Int64},x::Matrix{Float64},op::MultiOrthoPoly)</code></pre><p>where <code>ind</code> is a matrix of multi-indices.</p><p>If <em>all</em> basis polynomials are to be evaluated at points <code>x</code>, then call</p><pre><code class="language-none">evaluate(x::Matrix{Float64},mop::MultiOrthoPoly) = evaluate(mop.ind,x,mop)</code></pre><p>which returns an array of dimensions <code>(mop.dim,size(x,1))</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ul><li><code>n</code> is a multi-index</li><li><code>length(n) == p</code>, i.e. a p-variate basis polynomial</li><li><code>size(x) = (N,p)</code>, where <code>N</code> is the number of points</li><li><code>size(a)==size(b)=p</code>.</li></ul></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/evaluate.jl#L3-L66">source</a></section><h2><a class="nav-anchor" id="Scalar-Products-1" href="#Scalar-Products-1">Scalar Products</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.computeSP2" href="#PolyChaos.computeSP2"><code>PolyChaos.computeSP2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">computeSP2(n::Int64,β::Vector{Float64})
computeSP2(n::Int64,op::OrthoPoly) = computeSP2(n,op.β)
computeSP2(op::OrthoPoly) = computeSP2(op.deg,op.β)
computeSP2(opq::OrthoPolyQ) = computeSP2(opq.op)</code></pre><p>Computes the <code>n</code> <em>regular</em> scalar products aka 2-norms of the orthogonal polynomials, namely</p><div>\[\|ϕ_i\|^2 = \langle \phi_i,\phi_i\rangle \quad \forall i \in \{ 0,\dots,n \}.\]</div><p>Notice that only the values of <code>β</code> of the recurrence coefficients <code>(α,β)</code> are required. The computation is based on equation (1.3.7) from Gautschi, W. &quot;Orthogonal Polynomials: Computation and Approximation&quot;. Whenever there exists an analytic expressions for <code>β</code>, this function should be used.</p><p>The function is multiply dispatched to facilitate its use with the composite types <code>OrthoPoly</code> and <code>OrthoPolyQ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/scalarproduct.jl#L135-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.computeSP" href="#PolyChaos.computeSP"><code>PolyChaos.computeSP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">computeSP(a::Vector{Int64},α::Vector{Float64},β::Vector{Float64},nodes::Vector{Float64},weights::Vector{Float64};issymmetric::Bool=false)
computeSP(a::Vector{Int64},op::OrthoPoly,q::Quad;issymmetric=issymmetric(op))
computeSP(a::Vector{Int64},opq::OrthoPolyQ)</code></pre><p><strong>Multivariate</strong></p><pre><code class="language-none">computeSP( a::Vector{Int64},
           α::Vector{Vector{Float64}},β::Vector{Vector{Float64}},
           nodes::Vector{Vector{Float64}},weights::Vector{Vector{Float64}},
           ind::Matrix{Int64};
           issymmetric::BitArray=falses(length(α)))
computeSP(a::Vector{Int64},op::Vector{OrthoPoly},q::Vector{Quad},ind::Matrix{Int64})
computeSP(a::Vector{Int64},mOP::MultiOrthoPoly)</code></pre><p>Computes the scalar product</p><div>\[\langle \phi_{a_1},\phi_{a_2},\cdots,\phi_{a_n} \rangle,\]</div><p>where <code>n = length(a)</code>. This requires to provide the recurrence coefficients <code>(α,β)</code> and the quadrature rule <code>(nodes,weights)</code>, as well as the multi-index <code>ind</code>. If provided via the keyword <code>issymmetric</code>, symmetry of the weight function is exploited. All computations of the multivariate scalar products resort back to efficient computations of the univariate scalar products. Mathematically, this follows from Fubini&#39;s theorem.</p><p>The function is multiply dispatched to facilitate its use with <code>OrthoPolyQ</code> or a suitable combination of <code>OrthoPoly</code> and its quadrature rule <code>Quad</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ul><li>Zero entries of <span>$a$</span> are removed automatically to simplify computations, which follows from</li></ul><div>\[\langle \phi_i, \phi_j, \phi_0,\cdots,\phi_0 \rangle = \langle \phi_i, \phi_j \rangle,\]</div><p>because <code>\phi_0 = 1</code>.</p><ul><li>It is checked whether enough quadrature points are supplied to solve the integral exactly.</li></ul></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/scalarproduct.jl#L55-L95">source</a></section><h2><a class="nav-anchor" id="Quadrature-Rules-1" href="#Quadrature-Rules-1">Quadrature Rules</a></h2><pre><code class="language-none">fejer
fejer2
clenshaw_curtis
quadgp
gauss
radau
radau_jacobi
radau_laguerre
lobatto
lobatto_jacobi</code></pre><h2><a class="nav-anchor" id="Polynomial-Chaos-1" href="#Polynomial-Chaos-1">Polynomial Chaos</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.mean" href="#Statistics.mean"><code>Statistics.mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">mean(x::Vector{Float64},op::OrthoPoly)
mean(x::Vector{Float64},opq::OrthoPolyQ)</code></pre><p><strong>Multivariate</strong></p><pre><code class="language-none">mean(x::Vector{Float64},mop::MultiOrthoPoly)</code></pre><p>compute mean of random variable with PCE <code>x</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/polynomial_chaos.jl#L275-L286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.var" href="#Statistics.var"><code>Statistics.var</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">var(x::Vector{Float64},op::OrthoPoly)
var(x::Vector{Float64},opq::OrthoPolyQ)</code></pre><p><strong>Multivariate</strong></p><pre><code class="language-none">var(x::Vector{Float64},mop::MultiOrthoPoly)</code></pre><p>compute variance of random variable with PCE <code>x</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/polynomial_chaos.jl#L296-L307">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.std" href="#Statistics.std"><code>Statistics.std</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">std(x::Vector{Float64},op::OrthoPoly)
std(x::Vector{Float64},opq::OrthoPolyQ)</code></pre><p><strong>Multivariate</strong></p><pre><code class="language-none">std(x::Vector{Float64},mop::MultiOrthoPoly)</code></pre><p>compute standard deviation of random variable with PCE <code>x</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/polynomial_chaos.jl#L322-L333">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.sampleMeasure" href="#PolyChaos.sampleMeasure"><code>PolyChaos.sampleMeasure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">sampleMeasure(n::Int64,name::String,w::Function,dom::Tuple{Float64,Float64},symm::Bool,d::Dict;method::String=&quot;adaptiverejection&quot;)
sampleMeasure(n::Int64,m::Measure;method::String=&quot;adaptiverejection&quot;)
sampleMeasure(n::Int64,op::OrthoPoly;method::String=&quot;adaptiverejection&quot;)
sampleMeasure(n::Int64,opq::OrthoPolyQ;method::String=&quot;adaptiverejection&quot;)</code></pre><p>Draw <code>n</code> samples from the measure <code>m</code> described by its</p><ul><li><code>name</code></li><li>weight function <code>w</code>,</li><li>domain <code>dom</code>,</li><li>symmetry property <code>symm</code>,</li><li>and, if applicable, parameters stored in the dictionary <code>d</code>.</li></ul><p>By default an adaptive rejection sampling method is used (from <a href="https://github.com/mauriciogtec/AdaptiveRejectionSampling.jl">AdaptiveRejectionSampling.jl</a>), unless it is a common random variable for which <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a> is used.</p><p>The function is multiply dispatched to accept <code>OrthoPoly</code> or <code>OrthoPolyQ</code>.</p><p><strong>Multivariate</strong></p><pre><code class="language-none">sampleMeasure(n::Int64,m::MultiMeasure;method::Vector{String}=[&quot;adaptiverejection&quot; for i=1:length(m.name)])
sampleMeasure(n::Int64,mop::MultiOrthoPoly;method::Vector{String}=[&quot;adaptiverejection&quot; for i=1:length(mop.meas.name)])</code></pre><p>Multivariate extension which provides array of samples with <code>n</code> rows and as many columns as the multimeasure has univariate measures.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/polynomial_chaos.jl#L148-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.evaluatePCE" href="#PolyChaos.evaluatePCE"><code>PolyChaos.evaluatePCE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evaluatePCE(x::Vector{Float64},ξ::Vector{Float64},α::Vector{Float64},β::Vector{Float64})</code></pre><p>Evaluation of polynomial chaos expansion</p><div>\[\mathsf{x} = \sum_{i=0}^{L} x_i \phi_i{\xi_j},\]</div><p>where <code>L+1 = length(x)</code> and <span>$x_j$</span> is the <span>$j$</span>th sample where <span>$j=1,\dots,m$</span> with <code>m = length(ξ)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/polynomial_chaos.jl#L206-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.samplePCE" href="#PolyChaos.samplePCE"><code>PolyChaos.samplePCE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Univariate</strong></p><pre><code class="language-none">samplePCE(n::Int64,x::Vector{Float64},op::OrthoPoly;method::String=&quot;adaptiverejection&quot;)
samplePCE(n::Int64,x::Vector{Float64},opq::OrthoPolyQ;method::String=&quot;adaptiverejection&quot;)</code></pre><p>Combines <a href="#PolyChaos.sampleMeasure"><code>sampleMeasure</code></a> and <a href="#PolyChaos.evaluatePCE"><code>evaluatePCE</code></a>, i.e. it first draws <code>n</code> samples from the measure, then evaluates the PCE for those samples.</p><p><strong>Multivariate</strong></p><pre><code class="language-none">samplePCE(n::Int64,x::Vector{Float64},mop::MultiOrthoPoly;method::Vector{String}=[&quot;adaptiverejection&quot; for i=1:length(mop.meas.name)])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/polynomial_chaos.jl#L249-L262">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.calculateAffinePCE" href="#PolyChaos.calculateAffinePCE"><code>PolyChaos.calculateAffinePCE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">calculateAffinePCE(α::Vector{Float64})::Vector{Float64}</code></pre><p>Computes the affine PCE coefficients <span>$x_0$</span> and <span>$x_1$</span> from recurrence coefficients <span>$lpha$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/polynomial_chaos.jl#L11-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.convert2affinePCE" href="#PolyChaos.convert2affinePCE"><code>PolyChaos.convert2affinePCE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">convert2affinePCE(a::Vector{Float64},α0::Float64)
convert2affinePCE(name::String,p1::Float64,p2::Float64,d::Dict=Dict();kind::Symbol=:lbub)</code></pre><p>Computes the affine PCE coefficients <span>$x_0$</span> and <span>$x_1$</span> from</p><div>\[X = a_1 + a_2 \Xi = x_0 + x_1 \phi_1(\Xi),\]</div><p>where <span>$\phi_1(t) = t-\alpha_0$</span> is the first-order monic basis polynomial.</p><p>For classical polynomials the <code>name</code> can be given directly. The keyword <code>kind in [:lbub, :μσ]</code> specifies whether <code>p1</code> and <code>p2</code> have the meaning of lower/upper bounds or mean/standard deviation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/polynomial_chaos.jl#L29-L42">source</a></section><h2><a class="nav-anchor" id="Auxiliary-Functions-1" href="#Auxiliary-Functions-1">Auxiliary Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.nw" href="#PolyChaos.nw"><code>PolyChaos.nw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nw(q::Quad)
nw(opq::OrthoPolyQ)
nw(opq::Vector{OrthoPolyQ})
nw(mOP::MultiOrthoPoly)</code></pre><p>returns nodes and weights in matrix form</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/auxfuns.jl#L18-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.coeffs" href="#PolyChaos.coeffs"><code>PolyChaos.coeffs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coeffs(op::OrthoPoly)
coeffs(opq::OrthoPolyQ)
coeffs(op::Vector{OrthoPoly})
coeffs(opq::Vector{OrthoPolyQ})
coeffs(mop::MultiOrthoPoly)</code></pre><p>returns recurrence coefficients of in matrix form</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/auxfuns.jl#L43-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PolyChaos.integrate" href="#PolyChaos.integrate"><code>PolyChaos.integrate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">integrate(f::Function,nodes::Vector{Float64},weights::Vector{Float64})
integrate(f::Function,q::Quad)
integrate(f::Function,opq::OrthogonalPolyQ)</code></pre><p>integrate function <code>f</code> using quadrature rule specified via <code>nodes</code>, <code>weights</code>. For example <span>$\int_0^1 6x^5 = 1$</span> can be solved as follows:</p><pre><code class="language-">julia&gt; opq = OrthoPolyQ(&quot;uniform01&quot;,3)
julia&gt; integrate(x-&gt;6x^5,opq)
1.0000000000000002</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><ul><li>function <span>$f$</span> is assumed to return a scalar.</li><li>interval of integration is &quot;hidden&quot; in <code>nodes</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/auxfuns.jl#L71-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.issymmetric" href="#LinearAlgebra.issymmetric"><code>LinearAlgebra.issymmetric</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">issymmetric(m::Measure)::Bool
issymmetric(op::OrthoPoly)::Bool
issymmetric(q::Quad)::Bool
issymmetric(opq::OrthoPolyQ)::Bool</code></pre><p>Is the measure symmetric (around any point in the domain)?</p></div></div><a class="source-link" target="_blank" href="https://github.com/timueh/PolyChaos.jl/blob/0f0472aa78e91da32278e2ba887efc683566bf92/src/auxfuns.jl#L96-L104">source</a></section><footer><hr/><a class="previous" href="../math/"><span class="direction">Previous</span><span class="title">Mathematical Background</span></a></footer></article></body></html>
