<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimal Power Flow · PolyChaos.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/myfont.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="PolyChaos.jl logo"/></a><h1>PolyChaos.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Overview</a></li><li><a class="toctext" href="../type_hierarchy/">Type Hierarchy</a></li><li><span class="toctext">Usage</span><ul><li><a class="toctext" href="../numerical_integration/">Numerical Integration</a></li><li><a class="toctext" href="../quadrature_rules/">Quadrature Rules</a></li><li><a class="toctext" href="../orthogonal_polynomials_canonical/">Univariate Monic Orthogonal Polynomials</a></li><li><a class="toctext" href="../gaussian_mixture_model/">Gaussian mixture models</a></li><li><a class="toctext" href="../multiple_discretization/">Multiple Discretization</a></li><li><a class="toctext" href="../scalar_products/">Computation of Scalar Products</a></li><li><span class="toctext">Polynomial Chaos</span><ul><li><a class="toctext" href="../pce_tutorial/">Basic Usage</a></li><li><a class="toctext" href="../chi_squared_k1/">Chi Squared, One DOF</a></li><li><a class="toctext" href="../chi_squared_k_greater1/">Chi Squared, Several DOFs</a></li><li><a class="toctext" href="../random_ode/">Random ODE</a></li></ul></li><li class="current"><a class="toctext" href>Optimal Power Flow</a><ul class="internal"></ul></li></ul></li><li><a class="toctext" href="../math/">Mathematical Background</a></li><li><a class="toctext" href="../functions/">Functions</a></li></ul></nav><article id="docs"><header><nav><ul><li>Usage</li><li><a href>Optimal Power Flow</a></li></ul><a class="edit-page" href="https://github.com/timueh/PolyChaos.jl/blob/master/docs/src/DCsOPF.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Optimal Power Flow</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h1><a class="nav-anchor" id="Chance-Constrained-DC-Optimal-Power-Flow-1" href="#Chance-Constrained-DC-Optimal-Power-Flow-1">Chance-Constrained DC Optimal Power Flow</a></h1><p>The purpose of this tutorial is to show how polynomial chaos can be leveraged to solve optimization problems under uncertainty. Specifically, we study chance-constrained DC optimal power flow as it is presented in <a href="https://www.sciencedirect.com/science/article/pii/S235246771830105X">this paper</a>.</p><p>We consider the following 4-bus system that has a total of two generators (buses 1 and 3) and two loads (buses 2 and 4):</p><p><img src="../assets/DCsOPF_drawing.png" alt="4-bus system"/></p><p>We formalize the numbering of the generators (superscript <span>$g$</span>), loads (superscript <span>$d$</span> for demand), and branches (superscript <span>$br$</span>) as follows</p><div>\[\mathcal{N}^g = \{ 1, 3\}, \, \mathcal{N}^d = \{ 2, 4\}, \, \mathcal{N}^{br} = \{ 1, 2, 3, 4, 5 \}.\]</div><p>With each generator we associate a linear cost with cost coefficient <span>$c_i$</span> for all <span>$i \in \mathcal{N}^g$</span>. Each generator must adhere to its engineering limits given by <span>$(\underline{p}_i^g , \overline{p}_i^g )$</span> for all <span>$i \in \mathcal{N}^g$</span>. Also, each line is constrained by its limits <span>$(\underline{p}_i^{br}, \overline{p}_i^{br})$</span> for all <span>$i \in \mathcal{N}^{br}$</span>.</p><p>We model the demand at the buses <span>$i \in \mathcal{N}^d$</span> in terms of uniform distributions with known mean <span>$\mu_i$</span> and standard deviation <span>$\sigma_i$</span>. We concisely write</p><div>\[\mathsf{p}_i^d \sim \mathsf{U}(\mu_i, \sigma_i) \quad \forall i \in \mathcal{N}^d.\]</div><p>For simplicity we consider DC conditions. Hence, energy balance reads</p><div>\[\sum_{i \in \mathcal{N}^g} \mathsf{p}_i^g - \sum_{i \in \mathcal{N}^d} \mathsf{p}_i^d = 0,\]</div><p>and the vector of branch flows is computed from the power transfer distribution factor (PTDF) matrix <span>$\Psi$</span> via</p><div>\[\mathsf{p}^{br} = \Psi (C^p\mathsf{p}^g + C^d\mathsf{p}^d).\]</div><p>The matrices <span>$C^p$</span> and <span>$C^d$</span> map the generators and the loads to the correct buses, respectively.</p><p>We want to solve a chance-constrained optimal power flow problem under DC conditions. According to <a href="https://www.sciencedirect.com/science/article/pii/S235246771830105X">this paper</a>, we can formulate the problem as <span>$\underset{\mathsf{p^{g}}}{\operatorname{min}} \, \sum_{i \in \mathcal{N}_g} c_i \mathbb{E}( \mathsf{p}_i^g)$</span> subject to</p><div>\[\sum_{i \in \mathcal{N}^g} \mathsf{p}_i^g - \sum_{i \in \mathcal{N}^d} \mathsf{p}_i^d = 0, \\
\underline{p}_i^g \leq \mathbb{E}(\mathsf{p}_i^g) \pm \lambda_i^g \sqrt{\mathbb{V}(\mathsf{p}_i^g)} \leq \overline{p}_i^g  \forall i \in \mathcal{N}^g,\\
\underline{p}_i^{br} \leq \mathbb{E}(\mathsf{p}_i^{br}) \pm \lambda_i^{br} \sqrt{\mathbb{V}(\mathsf{p}_i^{br})} \leq \overline{p}_i^{br} \forall i \in \mathcal{N}^{br},\]</div><p>which minimizes the total expected generation cost subject to the DC power flow equations and chance-constrained engineering limits.</p><p>Let&#39;s solve the problem using <code>PolyChaos</code> and <code>JuMP</code>, using <code>Mosek</code> as a solver.</p><pre><code class="language-julia">using PolyChaos, JuMP, MosekTools, LinearAlgebra</code></pre><p>Let&#39;s define system-specific quantities such as the incidence matrix and the branch flow parameters. From these we can compute the PTDF matrix <span>$\Psi$</span> (assuming the slack is at bus 1).</p><pre><code class="language-julia">A = [ -1 1 0 0; -1 0 1 0; -1 0 0 1 ; 0 1 -1 0; 0 0 -1 1] # incidence matrix
Nl, N = size(A,1), size(A,2)
Bbr = diagm(0 =&gt; -( 2 .+ 10*rand(Nl) )) # line parameters
Ψ = [ zeros(Nl)  -Bbr*A[:,2:end]*inv(A[:,2:end]&#39;*Bbr*A[:,2:end]) ] # PTDF matrix</code></pre><pre><code class="language-none">5×4 Array{Float64,2}:
 0.0  -0.854476   -0.152014  -0.0758075
 0.0  -0.115526   -0.673186  -0.33571  
 0.0  -0.0299976  -0.1748    -0.588483 
 0.0  -0.145524    0.152014   0.0758075
 0.0   0.0299976   0.1748    -0.411517 </code></pre><p>Now we can continue the remaining ingredients that specify our systems:</p><pre><code class="language-julia">Cp, Cd = [1 0; 0 0; 0 0; 0 1], [0 0; 1 0; 0 1; 0 0 ] # book-keeping
Ng, Nd = size(Cp,2), size(Cd,2)
c = 4 .+ 10*rand(Ng) # cost function parameters
λp, λl = 1.6*ones(Ng), 1.6*ones(Nl) # lambdas for chance constraint reformulations
pmax, pmin = 10*ones(Ng), zeros(Ng) # engineering limits
plmax, plmin = 10*ones(Nl), -10*ones(Nl) # engineering limits</code></pre><pre><code class="language-none">([10.0, 10.0, 10.0, 10.0, 10.0], [-10.0, -10.0, -10.0, -10.0, -10.0])</code></pre><p>We specify the uncertainty using <code>PolyChaos</code>:</p><pre><code class="language-julia">deg = 1
opq = [Uniform01OrthoPoly(deg; Nrec=5*deg), Uniform01OrthoPoly(deg; Nrec=5*deg)]
mop = MultiOrthoPoly(opq, deg)
Npce = mop.dim</code></pre><pre><code class="language-none">3</code></pre><p>It remains to specify the PCE coefficients, for which we will use <code>convert2affine</code>.</p><pre><code class="language-julia">d = zeros(Nd,Npce) # PCE coefficients of load
d[1,[1,2]] = convert2affinePCE(1., 0.1, mop.uni[1], kind=&quot;μσ&quot;)
d[2,[1,3]] = convert2affinePCE(2., 0.2, mop.uni[2], kind=&quot;μσ&quot;)</code></pre><pre><code class="language-none">2-element Array{Float64,1}:
 2.0               
 0.6928203230275509</code></pre><p>Now, let&#39;s put it all into an optimization problem, specifically a second-order cone program. To build the second-order cone constraints we define a helper function <code>buildSOC</code>.</p><pre><code class="language-julia">function buildSOC(x::Vector,mop::MultiOrthoPoly)
    t = [ sqrt(Tensor(2,mop).get([i,i])) for i in 0:mop.dim-1 ]
    (t.*x)[2:end]
end</code></pre><pre><code class="language-none">buildSOC (generic function with 1 method)</code></pre><p>Finally, let&#39;s use <code>JuMP</code> to formulate and then solve the problem. We use <code>Mosek</code> to solve the problem; for academic use there are <a href="https://www.mosek.com/products/academic-licenses/">free license</a>.</p><pre><code class="language-">model = Model(with_optimizer(Mosek.Optimizer))
@variable(model, p[i in 1:Ng,j in 1:Npce], base_name=&quot;p&quot;)
@constraint(model, energy_balance[j in 1:Npce], sum(p[i,j] for i in 1:Ng) - sum(d[i,j] for i in 1:Nd) == 0)
@constraint(model, con_pmax[i in 1:Ng], [1/λp[i]*(pmax[i] - mean(p[i,:],mop)); buildSOC(p[i,:],mop)] in SecondOrderCone())
@constraint(model, con_pmin[i in 1:Ng], [1/λp[i]*(mean(p[i,:],mop) - pmin[i]); buildSOC(p[i,:],mop)] in SecondOrderCone())
pl = Ψ*(Cp*p + Cd*d)
@constraint(model, con_plmax[i in 1:Nl], [1/λl[i]*(plmax[i] - mean(pl[1,:],mop)); buildSOC(pl[i,:],mop)] in SecondOrderCone())
@constraint(model, con_plmin[i in 1:Nl], [1/λl[i]*(mean(pl[1,:],mop) - plmin[i]); buildSOC(pl[i,:],mop)] in SecondOrderCone())
@objective(model, Min, sum( mean(p[i,:],mop)*c[i] for i in 1:Ng) )
optimize!(model) # here we go</code></pre><p>Let&#39;s extract the numerical values of the optimal solution.</p><pre><code class="language-">@assert termination_status(model) == MOI.OPTIMAL &quot;Model not solved to optimality.&quot;
psol, plsol, obj = value.(p), value.(pl), objective_value(model)</code></pre><p>Great, we&#39;ve solved the problem. How do we now make sense of the solution? For instance, we can look at the moments of the generated power:</p><pre><code class="language-">p_moments = [ [mean(psol[i,:],mop) var(psol[i,:],mop) ] for i in 1:Ng ]</code></pre><p>Simiarly, we can study the moments for the branch flows:</p><pre><code class="language-">pbr_moments = [ [mean(plsol[i,:],mop) var(plsol[i,:],mop) ] for i in 1:Nl ]</code></pre><footer><hr/><a class="previous" href="../random_ode/"><span class="direction">Previous</span><span class="title">Random ODE</span></a><a class="next" href="../math/"><span class="direction">Next</span><span class="title">Mathematical Background</span></a></footer></article></body></html>
