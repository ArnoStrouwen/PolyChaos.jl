<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Type Hierarchy · PolyChaos.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/myfont.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="PolyChaos.jl logo"/></a><h1>PolyChaos.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Overview</a></li><li class="current"><a class="toctext" href>Type Hierarchy</a><ul class="internal"><li><a class="toctext" href="#AbstractMeasure-1">AbstractMeasure</a></li><li><a class="toctext" href="#AbstractOrthoPoly-1">AbstractOrthoPoly</a></li><li><a class="toctext" href="#OrthoPoly-1">OrthoPoly</a></li><li><a class="toctext" href="#MultiOrthoPoly-1">MultiOrthoPoly</a></li><li><a class="toctext" href="#AbstractCanonicalOrthoPoly-1">AbstractCanonicalOrthoPoly</a></li><li><a class="toctext" href="#Quad-1">Quad</a></li><li><a class="toctext" href="#Tensor-1">Tensor</a></li></ul></li><li><span class="toctext">Usage</span><ul><li><a class="toctext" href="../numerical_integration/">Numerical Integration</a></li><li><a class="toctext" href="../quadrature_rules/">Quadrature Rules</a></li><li><a class="toctext" href="../orthogonal_polynomials_canonical/">Univariate Monic Orthogonal Polynomials</a></li><li><a class="toctext" href="../gaussian_mixture_model/">Gaussian mixture models</a></li><li><a class="toctext" href="../multiple_discretization/">Multiple Discretization</a></li><li><a class="toctext" href="../scalar_products/">Computation of Scalar Products</a></li><li><span class="toctext">Polynomial Chaos</span><ul><li><a class="toctext" href="../pce_tutorial/">Basic Usage</a></li><li><a class="toctext" href="../chi_squared_k1/">Chi Squared, One DOF</a></li><li><a class="toctext" href="../chi_squared_k_greater1/">Chi Squared, Several DOFs</a></li><li><a class="toctext" href="../random_ode/">Random ODE</a></li></ul></li><li><a class="toctext" href="../DCsOPF/">Optimal Power Flow</a></li></ul></li><li><a class="toctext" href="../math/">Mathematical Background</a></li><li><a class="toctext" href="../functions/">Functions</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Type Hierarchy</a></li></ul><a class="edit-page" href="https://github.com/timueh/PolyChaos.jl/blob/master/docs/src/type_hierarchy.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Type Hierarchy</span><a class="fa fa-bars" href="#"></a></div></header><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If you are unfamiliar with the mathematical background of orthogonal polynomials, check out <a href="../math/#MathematicalBackground-1">this tutorial</a>.</p></div></div><h1><a class="nav-anchor" id="Type-Hierarchy-1" href="#Type-Hierarchy-1">Type Hierarchy</a></h1><p>Let&#39;s look at the types <code>PolyChaos</code> provides. There are four <code>AbstractTypes</code>: <code>AbstractMeasure</code>, <code>AbstractOrthoPoly</code>, <code>AbstractQuad</code>, and <code>AbstractTensor</code>. <code>AbstractMeasure</code> is the core on which <code>AbstractOrthoPoly</code> builds, on which <code>AbstractQuad</code> builds, which is then used by <code>AbstractTensor</code>.</p><h2><a class="nav-anchor" id="AbstractMeasure-1" href="#AbstractMeasure-1">AbstractMeasure</a></h2><p>The type tree for <code>AbstractMeasure</code> looks as follows</p><pre><code class="language-julia">julia&gt; using AbstractTrees, PolyChaos
julia&gt; AbstractTrees.children(x::Type) = subtypes(x)
julia&gt; print_tree(AbstractMeasure)
AbstractMeasure
├─ AbstractCanonicalMeasure
│  ├─ Beta01Measure
│  ├─ GammaMeasure
│  ├─ GaussMeasure
│  ├─ HermiteMeasure
│  ├─ JacobiMeasure
│  ├─ LaguerreMeasure
│  ├─ LegendreMeasure
│  ├─ LogisticMeasure
│  ├─ MeixnerPollaczekMeasure
│  ├─ Uniform01Measure
│  ├─ genHermiteMeasure
│  └─ genLaguerreMeasure
├─ Measure
└─ ProductMeasure</code></pre><p>There are several canonical measures that <code>PolyChaos</code> provides, all gathered in as subtypes of <code>AbstractCanonicalMeasure</code>. The <code>Measure</code> type is a generic measure, and <code>ProductMeasure</code> has an obvious meaning.</p><p>What are the relevant fields?</p><h3><a class="nav-anchor" id="Measure-1" href="#Measure-1">Measure</a></h3><p>It all begins with a measure, more specifically absolutely continuous measures. What are the fields of such a type <code>Measure</code>?</p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>name::String</code></td><td style="text-align: right">Name of measure</td></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right">Weight function <span>$w: \Omega \rightarrow \mathbb{R}$</span></td></tr><tr><td style="text-align: right"><code>dom::Tuple{Real,Real}</code></td><td style="text-align: right">Domain $ \Omega$</td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">Is <span>$w$</span> symmetric relative to some <span>$m \in \Omega$</span>, hence <span>$w(m-x) = w(m+x)$</span> for all <span>$x \in \Omega$</span>?</td></tr><tr><td style="text-align: right"><code>pars::Dict</code></td><td style="text-align: right">Additional parameters (e.g. shape parameters for Beta distribution)</td></tr></table><p>They are a <code>name</code>, a weight function <span>$w: \Omega \rightarrow \mathbb{R}$</span> with domain <span>$\Omega$</span> (<code>dom</code>). If the weight function is symmetric relative to some <span>$m \in \Omega$</span>, the field <code>symmetric</code> should be set to <code>true</code>. Symmetry relative to <span>$m$</span> means that</p><div>\[\forall x \in \Omega: \quad w(m-x) = w(m+x).\]</div><p>For example, the Gaussian probability density</p><div>\[w(x) = \frac{1}{\sqrt{2\pi}} \mathrm{e}^{-x^2/2}\]</div><p>is symmetric relative to the origin <span>$m=0$</span>. If the weight function has any parameters, then they are stored in the dictionary <code>pars</code>. For example, the probability density of the Beta distribution on <span>$\Omega = [0,1]$</span> has two positive shape parameters <span>$\alpha, \beta &gt; 0$</span></p><div>\[w(x) = \frac{1}{B(\alpha,\beta)} x^{\alpha-1} (1-x)^{\beta-1}.\]</div><p><a href="../orthogonal_polynomials_canonical/#UnivariateMonicOrthogonalPolynomials-1">This tutorial shows the above in action.</a></p><h3><a class="nav-anchor" id="ProductMeasure-1" href="#ProductMeasure-1">ProductMeasure</a></h3><p>So far, everything was univariate, the weight of the measure was mapping real numbers to real numbers. <code>PolyChaos</code> can handle product measures too. Let&#39;s assume the weight function is a product of two independent Gaussian densities</p><div>\[w: \mathbb{R} \times \mathbb{R} \rightarrow \mathbb{R}, \quad w(x) = \frac{1}{\sqrt{2\pi}} \mathrm{e}^{x_1^2/2} \frac{1}{\sqrt{2\pi}} \mathrm{e}^{x_2^2/2}.\]</div><p>The type <code>ProductMeasure</code> serves this purpose, with its straightforward fields</p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right">Weight function</td></tr><tr><td style="text-align: right"><code>measures::Vector{&lt;:AbstractMeasure}</code></td><td style="text-align: right">Vector of univariate measures</td></tr></table><p><a href="../orthogonal_polynomials_canonical/#MultivariateMonicOrthogonalPolynomials-1">This tutorial shows the above in action.</a></p><h3><a class="nav-anchor" id="Canonical-Measures-1" href="#Canonical-Measures-1">Canonical Measures</a></h3><p>Canonical measures are special, because we know their orthogonal polynomials. That is why several canonical measures are pre-defined in <code>PolyChaos</code>. Some of them may require additional parameters. (alphabetical order)</p><h4><a class="nav-anchor" id="Beta01Measure-1" href="#Beta01Measure-1">Beta01Measure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right"><span>$\frac{1}{B(\alpha,\beta)}  t^{\alpha-1} (1-t)^{\beta-1}$</span></td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(0, 1)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">true if <span>$\alpha = \beta$</span></td></tr><tr><td style="text-align: right"><code>ashapeParameter::Real</code></td><td style="text-align: right"><span>$\alpha &gt; 0$</span></td></tr><tr><td style="text-align: right"><code>bshapeParameter::Real</code></td><td style="text-align: right"><span>$\beta &gt; 0$</span></td></tr></table><h4><a class="nav-anchor" id="GammaMeasure-1" href="#GammaMeasure-1">GammaMeasure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right"><span>$\frac{\beta^\alpha}{\Gamma(\alpha)} t^{\alpha-1} \exp(-\beta t)$</span></td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(0, \infty)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">false</td></tr><tr><td style="text-align: right"><code>shapeParameter::Real</code></td><td style="text-align: right"><span>$\alpha &gt; 0$</span></td></tr><tr><td style="text-align: right"><code>rateParameter::Real</code></td><td style="text-align: right"><span>$1$</span></td></tr></table><h4><a class="nav-anchor" id="GaussMeasure-1" href="#GaussMeasure-1">GaussMeasure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right"><span>$\frac{1}{\sqrt{2 \pi}} \, \exp \left( - \frac{t^2}{2} \right)$</span></td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(-\infty, \infty)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">true</td></tr></table><h4><a class="nav-anchor" id="HermiteMeasure-1" href="#HermiteMeasure-1">HermiteMeasure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right">$ \exp\left( - t^2 \right)$</td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(-\infty, \infty)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">true</td></tr></table><h4><a class="nav-anchor" id="JacobiMeasure-1" href="#JacobiMeasure-1">JacobiMeasure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(-1, 1)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">true if <span>$\alpha = \beta$</span></td></tr><tr><td style="text-align: right"><code>ashapeParameter::Real</code></td><td style="text-align: right"><span>$\alpha &gt; -1$</span></td></tr><tr><td style="text-align: right"><code>bshapeParameter::Real</code></td><td style="text-align: right"><span>$\beta &gt; -1$</span></td></tr></table><h4><a class="nav-anchor" id="LaguerreMeasure-1" href="#LaguerreMeasure-1">LaguerreMeasure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right"><span>$\exp(-t)$</span></td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(0, \infty)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">true</td></tr></table><h4><a class="nav-anchor" id="LegendreMeasure-1" href="#LegendreMeasure-1">LegendreMeasure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right"><span>$1$</span></td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(-1, 1)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">true</td></tr></table><h4><a class="nav-anchor" id="LogisticMeasure-1" href="#LogisticMeasure-1">LogisticMeasure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right"><span>$\frac{\exp(-t)}{(1+\exp(-t))^2}$</span></td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(-\infty, \infty)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">true</td></tr></table><h4><a class="nav-anchor" id="MeixnerPollaczekMeasure-1" href="#MeixnerPollaczekMeasure-1">MeixnerPollaczekMeasure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right"><span>$\frac{1}{2 \pi} \exp((2\phi-\pi)t) \lvert\Gamma(\lambda + \mathrm{i}t)\rvert^2$</span></td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(-\infty,\infty)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">false</td></tr><tr><td style="text-align: right"><code>λParameter::Real</code></td><td style="text-align: right"><span>$\lambda &gt; 0$</span></td></tr><tr><td style="text-align: right"><code>ϕParameter::Real</code></td><td style="text-align: right"><span>$0 &lt; \phi &lt; \pi$</span></td></tr></table><h4><a class="nav-anchor" id="Uniform01Measure-1" href="#Uniform01Measure-1">Uniform01Measure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right"><span>$1$</span></td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(0, 1)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">true</td></tr></table><h4><a class="nav-anchor" id="genHermiteMeasure-1" href="#genHermiteMeasure-1">genHermiteMeasure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right">$ \lvert t \rvert^{2 \mu}\exp \left( - t^2 \right)$</td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(-\infty, \infty)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">true</td></tr><tr><td style="text-align: right"><code>muParameter::Real</code></td><td style="text-align: right"><span>$\mu &gt; -0.5$</span></td></tr></table><h4><a class="nav-anchor" id="genLaguerreMeasure-1" href="#genLaguerreMeasure-1">genLaguerreMeasure</a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>w::Function</code></td><td style="text-align: right"><span>$t^{\alpha}\exp(-t)$</span></td></tr><tr><td style="text-align: right"><code>dom::Tuple{&lt;:Real,&lt;:Real}</code></td><td style="text-align: right"><span>$(0,\infty)$</span></td></tr><tr><td style="text-align: right"><code>symmetric::Bool</code></td><td style="text-align: right">false</td></tr><tr><td style="text-align: right"><code>shapeParameter::Bool</code></td><td style="text-align: right"><span>$\alpha&gt;-1$</span></td></tr></table><h2><a class="nav-anchor" id="AbstractOrthoPoly-1" href="#AbstractOrthoPoly-1">AbstractOrthoPoly</a></h2><p>Orthogonal polynomials are at the heart of <code>PolyChaos</code>. The type tree for <code>AbstractOrthoPoly</code> looks as follows</p><pre><code class="language-julia">julia&gt; print_tree(AbstractOrthoPoly)
AbstractOrthoPoly
├─ AbstractCanonicalOrthoPoly
│  ├─ Beta01OrthoPoly
│  ├─ GammaOrthoPoly
│  ├─ GaussOrthoPoly
│  ├─ HermiteOrthoPoly
│  ├─ JacobiOrthoPoly
│  ├─ LaguerreOrthoPoly
│  ├─ LegendreOrthoPoly
│  ├─ LogisticOrthoPoly
│  ├─ MeixnerPollaczekOrthoPoly
│  ├─ Uniform01OrthoPoly
│  ├─ genHermiteOrthoPoly
│  └─ genLaguerreOrthoPoly
├─ MultiOrthoPoly
└─ OrthoPoly</code></pre><p>It mirrors the type tree from <code>AbstractMeasure</code>: there is a generica (univariate) type <code>OrthoPoly</code>, a multivariate extension <code>MultiOrthoPoly</code> for product measures, and several univariate canonical orthogonal polynomials.</p><h2><a class="nav-anchor" id="OrthoPoly-1" href="#OrthoPoly-1">OrthoPoly</a></h2><p>Given an absolutely continuous measure we are wondering what are the monic polynomials <span>$\phi_i: \Omega \rightarrow \mathbb{R}$</span> that are orthogonal relative to this very measure? Mathematically this reads</p><div>\[\langle \phi_i, \phi_j \rangle = \int_{\Omega} \phi_i(t) \phi_j(t) w(t) \mathrm{d}t =
\begin{cases}
&gt; 0, &amp; i=j \\
= 0, &amp; i\neq j.
\end{cases}\]</div><p>They can be constructed using the type <code>OrthoPoly</code>, which has the fields</p><table><tr><th style="text-align: right">Name</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>name::String</code></td><td style="text-align: right">Name</td></tr><tr><td style="text-align: right"><code>deg::Int</code></td><td style="text-align: right">Maximum degree</td></tr><tr><td style="text-align: right"><code>α::Vector{&lt;:Real}</code></td><td style="text-align: right">Vector of recurrence coefficients α</td></tr><tr><td style="text-align: right"><code>β::Vector{&lt;:Real}</code></td><td style="text-align: right">Vector of recurrence coefficients β</td></tr><tr><td style="text-align: right"><code>meas::AbstractMeasure</code></td><td style="text-align: right">Underlying measure</td></tr></table><p>The purpose of <code>name</code> is obvious. The integer <code>deg</code> stands for the maxium degree of the polynomials. Rather than storing the polynomials <span>$\phi_i$</span> themselves we store the recurrence coefficients <code>α</code>, <code>β</code> that characterize the system of orthogonal polynomials. These recurrence coefficients are the single most important piece of information for the orthogonal polynomials. For several common measures, there exist analytic formulae. These are built-in to <code>PolyChaos</code> and should be used whenever possible.</p><p><a href="../orthogonal_polynomials_canonical/#UnivariateMonicOrthogonalPolynomials-1">This tutorial shows the above in action.</a></p><h2><a class="nav-anchor" id="MultiOrthoPoly-1" href="#MultiOrthoPoly-1">MultiOrthoPoly</a></h2><p>Just as we did in the univariate case, we use <code>ProductMeasure</code> as a building block for multivariate orthogonal polynomials. The type <code>MultiOrthoPoly</code> combines product measures with the respective orthogonal polynomials and their quadrature rules. Its fields are</p><table><tr><th style="text-align: right">Name</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>name::Vector{String}</code></td><td style="text-align: right">Vector of names</td></tr><tr><td style="text-align: right"><code>deg::Int</code></td><td style="text-align: right">Maximum degree</td></tr><tr><td style="text-align: right"><code>dim::Int</code></td><td style="text-align: right">Dimension</td></tr><tr><td style="text-align: right"><code>ind::Matrix{&lt;:Int}</code></td><td style="text-align: right">Array of multi-indices</td></tr><tr><td style="text-align: right"><code>measure::ProductMeasure</code></td><td style="text-align: right">Underlying product measure</td></tr></table><p>The names of the univariate bases are stored in <code>names</code>; the maximum degree of the basis is <code>deg</code>; the overall dimension of the multivariate basis is <code>dim</code>; the multi-index <code>ind</code> maps the <span>$j$</span>-th multivariate basis to the elements of the univariate bases; the product measure is stored in <code>meas</code>; finally, all univariate bases are collected in <code>uni</code>.</p><p><a href="../orthogonal_polynomials_canonical/#MultivariateMonicOrthogonalPolynomials-1">This tutorial shows the above in action.</a></p><h2><a class="nav-anchor" id="AbstractCanonicalOrthoPoly-1" href="#AbstractCanonicalOrthoPoly-1">AbstractCanonicalOrthoPoly</a></h2><p>These are the bread-and-butter polynomials: polynomials for which we know analytic formulae for the recursion coefficients. The following canonical orthogonal polynomials are implemented</p><pre><code class="language-julia">julia&gt; print_tree(AbstractCanonicalOrthoPoly)
AbstractCanonicalOrthoPoly
├─ Beta01OrthoPoly
├─ GammaOrthoPoly
├─ GaussOrthoPoly
├─ HermiteOrthoPoly
├─ JacobiOrthoPoly
├─ LaguerreOrthoPoly
├─ LegendreOrthoPoly
├─ LogisticOrthoPoly
├─ MeixnerPollaczekOrthoPoly
├─ Uniform01OrthoPoly
├─ genHermiteOrthoPoly
└─ genLaguerreOrthoPoly</code></pre><p>Their fields follow</p><table><tr><th style="text-align: right">Name</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>deg::Int</code></td><td style="text-align: right">Maximum degree</td></tr><tr><td style="text-align: right"><code>α::Vector{&lt;:Real}</code></td><td style="text-align: right">Vector of recurrence coefficients</td></tr><tr><td style="text-align: right"><code>β::Vector{&lt;:Real}</code></td><td style="text-align: right">Vector of recurrence coefficients</td></tr><tr><td style="text-align: right"><code>measure::CanonicalMeasure</code></td><td style="text-align: right">Underlying canonical measure</td></tr><tr><td style="text-align: right"><code>quad::AbstractQuad</code></td><td style="text-align: right">Quadrature rule</td></tr></table><h2><a class="nav-anchor" id="Quad-1" href="#Quad-1">Quad</a></h2><p>Quadrature rules are intricately related to orthogonal polynomials. An <span>$n$</span>-point quadrature rule is a pair of so-called nodes <span>$t_k$</span> and weights <span>$w_k$</span> for <span>$k=1,\dots,n$</span> that allow to solve integrals relative to the measure</p><div>\[\int_\Omega f(t) w(t) \mathrm{d} t \approx \sum_{k=1}^n w_k f(t_k).\]</div><p>If the integrand <span>$f$</span> is polynomial, then the specific Gauss quadrature rules possess the remarkable property that an <span>$n$</span>-point quadrature rule can integrate polynomial integrands <span>$f$</span> of degree at most <span>$2n-1$</span> <em>exactly</em>; no approximation error is made.</p><p>The fields of <code>Quad</code> are</p><table><tr><th style="text-align: right">Name</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>name::String</code></td><td style="text-align: right">Name</td></tr><tr><td style="text-align: right"><code>Nquad::Int</code></td><td style="text-align: right">Number <span>$n$</span> of quadrature points</td></tr><tr><td style="text-align: right"><code>nodes::Vector{&lt;:Real}</code></td><td style="text-align: right">Nodes</td></tr><tr><td style="text-align: right"><code>weights::Vector{&lt;:Real}</code></td><td style="text-align: right">Weights</td></tr></table><p>with obvious meanings.</p><p><code>PolyChaos</code> provides the type <code>EmptyQuad</code> that is added in case no quadrature rule is desired.</p><p><a href="../numerical_integration/#NumericalIntegration-1">This tutorial shows the above in action.</a></p><h2><a class="nav-anchor" id="Tensor-1" href="#Tensor-1">Tensor</a></h2><p>The last type we need to address is <code>Tensor</code>. It is used to store the results of scalar products. Its fields are</p><table><tr><th style="text-align: right">Name</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>dim:</code></td><td style="text-align: right"><em>Dimension</em> <span>$m$</span> of tensor <span>$\langle \phi_{i_1} \phi_{i_2} \cdots \phi_{i_{m-1}}, \phi_{i_m} \rangle$</span></td></tr><tr><td style="text-align: right"><code>T::SparseVector{Float64,Int}</code></td><td style="text-align: right">Entries of tensor</td></tr><tr><td style="text-align: right"><code>get::Function</code></td><td style="text-align: right">Function to get entries from <code>T</code></td></tr><tr><td style="text-align: right"><code>op::AbstractOrthoPoly</code></td><td style="text-align: right">Underlying univariate orthogonal polynomials</td></tr></table><p>The <em>dimension</em> <span>$m$</span> of the tensor is the number of terms that appear in the scalar product. Let&#39;s assume we set <span>$m = 3$</span>, hence have <span>$\langle \phi_{i} \phi_{j}, \phi_{k} \rangle$</span>, then the concrete entry is obtained as <code>Tensor.get([i,j,k])</code>.</p><p><a href="../scalar_products/#ComputationOfScalarProducts-1">This tutorial shows the above in action.</a></p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Overview</span></a><a class="next" href="../numerical_integration/"><span class="direction">Next</span><span class="title">Numerical Integration</span></a></footer></article></body></html>
